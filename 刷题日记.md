# 刷题日记

## **22.07.07**

### 23 合并k个有序链表

思路一：堆

python中只有最小堆

可以将所有的节点值都直接放入堆中，然后依次取出链接但是这样的空间复杂度会高O(KN)。

```python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        import heapq

        if not lists: return None
        minheap = []
        for item in lists:
            while item:
                heapq.heappush(minheap, item.val)
                item = item.next
        pre = ListNode(-1)
        cur = pre
        while minheap:
            cur.next = ListNode(heapq.heappop(minheap))
            cur = cur.next
        return pre.next
```

空间复杂度优化：创建只有lists.length长度的堆，每次取出最小的节点后，再放入新的节点。

```python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        import heapq
        ListNode.__lt__ = lambda a, b: 0
        if not lists: return None
        nodeheap = []
        for node in lists:
            if node:
                heapq.heappush(nodeheap, (node.val, node))
        dummy = ListNode(-1)
        cur = dummy

        while nodeheap:
            val, node = heapq.heappop(nodeheap)
            cur.next = ListNode(val)
            cur = cur.next
            if node.next:
                heapq.heappush(nodeheap, (node.next.val, node.next))
        return dummy.next
```

思路二：归并法：

```python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        if not lists: return None
        res = self.mergesort(lists, 0, len(lists) - 1)
        return res

    # 边界值的定义要清晰，这里是两边都闭区间
    def mergesort(self, lists, l, r):
        if l == r:
            return lists[l]
        m = (l + r) // 2
        left = self.mergesort(lists, l, m)
        right = self.mergesort(lists, m + 1, r)
        return self.merge(left, right)

    def merge(self, l1, l2):
        pre = ListNode(-1)
        cur = pre
        while l1 and l2:
            if l1.val <= l2.val:
                cur.next = l1
                l1 = l1.next
            else:
                cur.next = l2
                l2 = l2.next
            cur = cur.next
        cur.next = l1 if l1 else l2
        return pre.next
```

### 648 单词替换

思路一：哈希

```python
class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        dictionarySet = set(dictionary)
        words = sentence.split(' ')
        for i, word in enumerate(words):
            for j in range(1, len(words) + 1):
                if word[:j] in dictionarySet:
                    words[i] = word[:j]
                    break
        return ' '.join(words)
```

思路二：字典树

根据题目给的**前缀(词根)创建字典树**，遍历句子中的每个单词，替换为第一个与字典树匹配的前缀。
与其他题目的Trie树的搜索用法不同的是，**我们不需要保证整个单词属于字典树中或整个单词可以拆解成字典树中的单词**，只需要找到第一次匹配到的前缀即可，所以这里写了一个新的查询方法。

```python
class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        trie = Trie()
        for d in dictionary:
            trie.insert(d)
        words = sentence.split(' ')
        return ' '.join(trie.find_sp(word) for word in words) 

class Trie:
    def __init__(self):
        self.root = {}

    def insert(self, word):
        node = self.root
        for w in word + "#":
            if w not in node:
                node[w] = {}
            node = node[w]

    def find(self, word):
        node = self.root
        for i in range(len(word)):
            if '#' in node:
                if self.find(word[i:]):
                    return True
            if word[i] in node:
                node = node[word[i]]
            else:
                return False
        return '#' in node

    def find_sp(self, word):
        node = self.root
        for i in range(len(word)):
            if "#" in node:
                return word[:i]
            if word[i] in node:
                node = node[word[i]]
            else:
                break
        return word
```

按照 labuladong 模板的写法：

```python
class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        # 建立前缀树 并把 dictionary 中词根加入到 trie 中
        trie = Trie()
        for d in dictionary:
            trie.insert(d)
        words = sentence.split(' ')
        for i in range(len(words)):
            prefix = trie.shortestPrefix(words[i])
            # 如果找到了最短前缀就用 prefix 替换
            if prefix:
                words[i] = prefix
        return ' '.join(words)

class Node:
    def __init__(self):
        self.children = collections.defaultdict(Node)
        self.isword = False

class Trie:
    def __init__(self):
        self.root = Node()

    def insert(self, word):
        node = self.root
        for w in word:
            node = node.children[w]
        node.isword = True

    def find(self, word):
        node = self.root
        for w in word:
            node = node.children.get(w)
            if node == None:
                return False
        return node.isword

    # 在所有键中找到 word 的最短前缀
    def shortestPrefix(self, word):
        node = self.root
        for i in range(len(word)):
            # 无法继续向下搜索
            if node == None:
                return ""
            # 找到一个键是 word 的前缀
            if node.isword:
                return word[:i]
            # 向下搜索
            node = node.children.get(word[i])
        # 如果 word 本身就是一个键
        if node and node.isword:
            return word
        return ""
```

## **22.07.08**

### 208 实现前缀树

这里只需要insert search startswith几个函数即可

```python
class Node:
    def __init__(self):
        self.children = collections.defaultdict(Node)
        self.isword = False

class Trie:

    def __init__(self):
        self.root = Node()

    def insert(self, word: str) -> None:
        node = self.root
        for w in word:
            node = node.children[w]
        node.isword = True

    def search(self, word: str) -> bool:
        node = self.root
        for w in word:
            node = node.children.get(w)
            if node == None:
                return False
        return node.isword

    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for w in prefix:
            node = node.children.get(w)
            if node == None: return False
        return True
```

### 211 添加查找单词

思路一：字典树

负雪明烛方法一：（超时）

```python
class Node:
    def __init__(self):
        self.children = collections.defaultdict(Node)
        self.isEnd = False

class WordDictionary(object):

    def __init__(self):
        self.root = Node()

    def addWord(self, word):
        node = self.root
        for w in word:
            node = node.children[w]
        node.isEnd = True

    def search(self, word):
        return self.match(word, idx, self.root)

    def match(word, idx, root):
        if not root:
            return False
        if idx == len(word):
            return root.isEnd
        if word[idx] != '.':
            return root and self.match(word, idx + 1, root.children.get(word[idx]))
        else:
            for child in root.children.values():
                if self.match(word, idx + 1, child):
                    return True
        return False
```

Ben bfs方法：（不超时）

```python
class WordDictionary(object):

    def __init__(self):
        self.trie = dict()

    def addWord(self, word):
        node = self.trie
        for ch in word:
            if ch not in node:
                node[ch] = {}
            node = node[ch]
        node["#"] = {}

    def search(self, word):
        word += '#'
        bfs = deque([(0, self.trie)])
        while bfs:
            idx, cur = bfs.popleft()
            if idx == len(word):
                return True
            if word[idx] == '.':
                for nxt in cur.values():
                    bfs.append((idx + 1, nxt))
            elif word[idx] in cur:
                bfs.append((idx + 1, cur[word[idx]]))
        return False
```

官方标准字典树模板：（不超时）

```python
class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.isEnd = False

    def insert(self, word):
        node = self
        for ch in word:
            ch = ord(ch) - ord('a')
            if not node.children[ch]:
                node.children[ch] = TrieNode()
            node = node.children[ch]
        node.isEnd = True


class WordDictionary:

    def __init__(self):
        self.trieRoot = TrieNode()

    def addWord(self, word: str) -> None:
        self.trieRoot.insert(word)

    def search(self, word: str) -> bool:

        def dfs(index, node):
            if index == len(word):
                return node.isEnd
            ch = word[index]

            if ch != '.':
                child = node.children[ord(ch) - ord('a')]
                if child is not None and dfs(index + 1, child):
                    return True
            else:
                for child in node.children:
                    if child is not None and dfs(index + 1, child):
                        return True
            return False

        return dfs(0, self.trieRoot)
```

思路二：哈希字典（单词长度作为键值）（超时）

```python
class WordDictionary:

    def __init__(self):
        self.words = collections.defaultdict(list)

    def addWord(self, word: str) -> None:
        self.words[len(word)] += [word]

    def search(self, word: str) -> bool:
        n = len(word)

        def f(s):
            for i in range(n):
                if word[i] not in {s[i], '.'}:
                    return False
            return True

        for s in self.words[n]:
            if f(s):
                return True
        return False
```

### 677 键值映射

思路一：字典树

不再是TrieSet，而是要记录value值的TrieMap

```python
class MapSum:

    def __init__(self):
        self.root = {}

    def insert(self, key: str, val: int) -> None:
        node = self.root
        for c in key:
            if c not in node:
                node[c] ={}
            node = node[c]
        node['val'] = val

    def sum(self, prefix: str) -> int:
        node = self.root
        for c in prefix:
            if c not in node:
                return 0
            node = node[c]
        ans = 0
        def dfs(node):
            for c in node:
                if c == 'val':
                    nonlocal ans
                    ans += node[c]
                else:
                    dfs(node[c])
        dfs(node)
        return ans
```

思路二：暴力法

使用内置的 startswith 函数进行判断。

```python
class MapSum:

    def __init__(self):
        self.dict = {}

    def insert(self, key: str, val: int) -> None:
        self.dict[key] = val

    def sum(self, prefix: str) -> int:
        res = 0
        for k, v in self.dict.items():
            if k.startswith(prefix):
                res += v
        return res
```

### 1217 玩筹码

思路：贪心

比较奇数和偶数位置数量的最小值即可。

```python
class Solution:
    def minCostToMoveChips(self, position: List[int]) -> int:
        cnt = Counter(p % 2 for p in position) ## 根据模 2 后的余数来统计奇偶个数
        return min(cnt[0], cnt[1])
```

## 22.07.09

### 873 最长斐波那契子序列长度

思路：经典动态规划应用问题

dp函数定义：`dp[j][i]`定义为以`arr[j]` 和 `arr[i]`作为结尾的最长斐波那契子序列长度。为了计算`dp[j][i]`的值需要得到该斐波那契序列 `arr[j]`前面一个数字，命名为 `arr[k]`。由于arr 是严格单调递增的，所以有 `k < j < i` 。由斐波那契数列的定义可以知道，斐波那契子序列的最小长度为3，因此状态转移方程可以写为：
$$
dp[j][i]=\left\{
\begin{aligned}
max(3,~ dp[k][j] + 1),  & 0 < k < j \\
0,  & k < 0~or~k > j
\end{aligned}
\right.
$$
同时可以进行一部分优化，由于arr 是严格单调递增的，只有当` arr[i] - arr[j] >= arr[j]`， 也即 `arr[i] >= arr[j] * 2`时才寻找k。

```python
class Solution:
    def lenLongestFibSubseq(self, arr: List[int]) -> int:
        n, idx_map, ans = len(arr), {x : i for i, x in enumerate(arr)}, 0
        dp = [[0] * n for _ in range(n)]
        for i in range(n):
            for j in range(n - 1, -1, -1):
                if arr[i] - arr[j] >= arr[j]: break
                if arr[i] - arr[j] in idx_map:
                    k = idx_map[arr[i] - arr[j]]
                    dp[j][i] = max(3, dp[k][j] + 1)
                    ans = max(ans, dp[j][i])
        return ans
```

benhao使用哈希对空间进行优化，因为使用dp数组会有一半的空间浪费

```python
class Solution:
    def lenLongestFibSubseq(self, arr: List[int]) -> int:
        # 初始化 n=数组长度  用ind_map记录元素出现的下标（严格递增不重复）
        n, idx_map, ans = len(arr), {x : i for i, x in enumerate(arr)}, 0
        # 根据hash索引 得到一个 新的hash表，其中的任何键的初始值都为2
        dp = defaultdict(lambda: defaultdict(lambda: 2))
        # 二重循环遍历 根据fib前两项 寻找是否存在 满足条件的第三项
        for i in range(n - 1):
            for j in range(i + 1, n):
                # 以i,j为fib前两项 并在数组中能够找到符合条件的最后一项

                # dp的初始值只包含i和j这两项 
                # 找到第三项后，以j,nxt结尾的子序列长度加上“i”这一项
                if (nxt := arr[i] + arr[j]) in idx_map:
                    dp[j][idx_map[nxt]] = dp[i][j] + 1
                    ans = max(ans, dp[j][idx_map[nxt]])
        return ans
```

## 22.07.10

### 741 摘樱桃

思路：动态规划

从（0,0）到（N-1，N-1），再从（N-1，N-1）到（0,0）。可以视为两个人同时从（0,0）走到（N-1，N-1）。但是要限制两个人走到同一个格子时，只能摘一个樱桃。

对于两个人位置的描述，可以只用三个参数即可。假设两个人的初始位置相同且速度相同，那么不论两个人怎么走，两个人的步数都是相同的（设为k）。这时如果两个人的坐标分别为 (x1, y1) 和 (x2, y2) ，那么有 `x1 + y1 = x2 + y2 = k`，所以A B两个人的位置可以表示为 (x1, k - x1) 和 (x2, k - x2)。那么当 `x1 = x2`时，两个人的位置肯定是相同的。

定义状态函数 `dp[k][x1][x2]` 表示为 两个人分别从（x1, k - x1） 和 (x2, k - x2) 出发到达（N-1，N-1）时，摘到的樱桃个数之和的最大值。

如果（x1, k - x1） 或 (x2, k - x2)  是荆棘，则 `dp[k][x1][x2] = -inf`

那么A B 从上一步走过来的情况一共有四种，分别为：

- 都往右：从`dp[k-1][x1][x2]`来
- A往下，B往右：从`dp[k-1][x1-1][x2]`来
- A往右，B往下：从`dp[k-1][x1][x2-1]`来
- 都往下：从`dp[k-1][x1-1][x2-1]`来

取这四种情况的最大值，再加上`grid[x1][k-x1]` 和 `grid[x2][k-x2]`的值，就得到了`dp[k][x1][x2]`，如果`x1 = x2`，那么只用加上`grid[x1][k-x1]`的值。

最后的答案为`max(dp[2n-2][n-1][n-1], 0)`，跟0取max是因为可能存在所有路都被荆棘挡住的情况。

```python
class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        n = len(grid)
        dp = [[[-inf] * n for _ in range(n)] for _ in range(n * 2 - 1)]
        dp[0][0][0] = grid[0][0]
        for k in range(1, n * 2 - 1):
            for x1 in range(max(k - n + 1, 0), min(k + 1, n)):
                y1 = k - x1
                if grid[x1][y1] == -1:
                    continue
                for x2 in range(x1, min(k + 1, n)):
                    y2 = k - x2
                    if grid[x2][y2] == -1:
                        continue
                    res = dp[k - 1][x1][x2] # 都往右
                    if x1:
                        res = max(res, dp[k - 1][x1 - 1][x2]) # 往下， 往右
                    if x2:
                        res = max(res, dp[k - 1][x1][x2 - 1]) # 往右，往下
                    if x1 and x2:
                        res = max(res, dp[k - 1][x1 - 1][x2 - 1]) # 都往下
                    res += grid[x1][y1]
                    if x2 != x1:    # 避免重复摘同一个樱桃
                        res += grid[x2][y2]
                    dp[k][x1][x2] = res
        return max(dp[-1][-1][-1], 0)
```

## 22.07.11

### 676 实现一个魔法字典

**思路一：模拟**

将字典中的单词按照单词长度存入字典，然后搜索的时候遍历 `searchword`长度的即可

自己写的超级笨比写法：

```python
class MagicDictionary:

    def __init__(self):
        self.dic = defaultdict(list)

    def buildDict(self, dictionary: List[str]) -> None:
        for i in range(len(dictionary)):
            self.dic[len(dictionary[i])] += [dictionary[i]]

    def search(self, searchWord: str) -> bool:
        n = len(searchWord)
        if n not in self.dic:
            return False
        ans = [False] * len(self.dic[n])
        for i in range(len(self.dic[n])):
            if self.diff(self.dic[n][i], searchWord) == 1:
                ans[i] = True
        return True in ans


    def diff(self, s1, s2):
        ans = 0
        n = len(s1)
        for i in range(n):
            if s1[i] != s2[i]:
                ans += 1
        return ans
```

benhao大佬的简介写法：

```python
class MagicDictionary:

    def __init__(self):
        self.dic = defaultdict(list)

    def buildDict(self, dictionary: List[str]) -> None:
        for d in dictionary:
            self.dic[len(d)].append(d)

    def search(self, searchWord: str) -> bool:
        for d in self.dic[len(searchWord)]:
            if sum(c0 != c1 for c0, c1 in zip(searchWord, d)) == 1:
                return True
        return False
```

我怎么就没有想到直接用zip组合 然后直接判断呢，还多写了一个函数，对比一下，发现自己的方法太笨了

**思路二：字典树**

我们也可以使用字典树代替数组，将所有字符串进行存储。

在查询时，我们可以使用递归 + 回溯的方法，使用递归函数`dfs(node, posmodified)`，其中的变量分别表示：当前遍历到的字典树上的节点是 `node` 以及待查询字符串 `searchWord` 的第`pos` 个字符，并且在之前的遍历中是否已经替换过恰好一个字符（如果替换过，那么 `modified` 为true，否则为  false）。

如果`node` 有一个值为 `searchWord[pos]` 的子节点，那么我们就可以继续进行递归。同时，如果`modified` 为`false`，我们可以将 `searchWord[pos]`替换成任意一个是 `node` 子节点的字符，将 `modified` 置为`true` 并继续进行递归。

当`pos` 等于`searchWord` 的长度时，说明递归完成。此时我们需要检查`node` 是否是一个字典树上的结束节点（即一个单词的末尾），同时需要保证 `modified` 为 `true`，因为我们必须进行一次修改。

```python
class Trie:
    def __init__(self):
        self.is_finished = False
        self.child = dict()

class MagicDictionary:

    def __init__(self):
        self.root = Trie()

    def buildDict(self, dictionary: List[str]) -> None:
        for word in dictionary:
            cur = self.root
            for ch in word:
                if ch not in cur.child:
                    cur.child[ch] = Trie()
                cur = cur.child[ch]
            cur.is_finished = True

    def search(self, searchWord: str) -> bool:
        def dfs(node: Trie, pos:int, modified:bool):
            if pos == len(searchWord):
                return modified and node.is_finished

            ch = searchWord[pos]
            if ch in node.child:
                if dfs(node.child[ch], pos + 1, modified):
                    return True

            if not modified:
                for cnext in node.child:
                    if ch != cnext:
                        if dfs(node.child[cnext], pos + 1, True):
                            return True
            return False

        return dfs(self.root, 0, False)
```

### 1 两数之和

思路一：暴力遍历

暴力遍历的时间复杂度是O(N^2)，但是居然没有超时。不过我看我两年前的暴力遍历测试用时很短，现在已经很长了。

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums) - 1):
            for j in range(i + 1, len(nums)):
                if nums[i] + nums[j] == target:
                    return i, j
```

思路二：哈希

将所有数的值-索引 存到字典中，然后查找每一个`target -num`是否在字典中，并且是否是原来那个数。

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        index = {}
        for i in range(len(nums)):
            index[nums[i]] = i
        for i, num in enumerate(nums):
            j = index.get(target - num)
            if j is not None and i != j:
                return [i, j]
```



## 22.07.12

### 1252 奇数单元格的数目

思路：直接模拟

```python
class Solution:
    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:
        matrix = [[0] * n for _ in range(m)]
        for r, c in indices:
            for i in range(n):
                matrix[r][i] += 1
            for row in matrix:
                row[c] += 1
        return sum(x % 2 for row in matrix for x in row)
```

`sum()`函数的使用不够熟练，要学会写成一行的简洁形式



### 1 两数相加

思路：模拟

```python
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        pre = ListNode(-1)
        cur = pre
        flag = 0
        while l1 or l2:
            x = l1.val if l1 else 0
            y = l2.val if l2 else 0
            sum = x + y + flag
            cur.next = ListNode(sum % 10)
            cur = cur.next
            flag = sum // 10
            if l1: l1 = l1.next
            if l2: l2 = l2.next
        if flag:
            cur.next = ListNode(1)
        return pre.next
```

> 思考：在循环的开始是就应该确认x，y的值，然后当遇到一个链表遍历至结尾，另一个还没结束时，取0，而不是在后面加节点，这样会导致无法跳出循环。
>
> 大致流程是没有问题的。但是在一些细节上的考虑还不够全面。



## 22.07.13

### 3 无重复的最长子串

思路：滑动窗口

这题是较为简单的滑动窗口题，仅需要统计窗口内字符的数量即可。

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        windows = defaultdict(int)
        left, right = 0, 0
        res = 0
        while right < len(s):
            c = s[right]
            right += 1
            windows[c] += 1
            while windows[c] > 1:
                d = s[left]
                left += 1
                windows[d] -= 1
            res = max(res, right - left)
        return res
```

> 要熟练滑动窗口的模板。



### 735 行星碰撞

思路：栈模拟

使用`stack`模拟行星碰撞，`alive`记录行星是否还存在，从左往右遍历 `asteriods`中的行星`ast`。

当 行星`ast`存在且`ast < 0`， 并且`stack` 非空且栈顶元素`stack[-1] > 0`，两个行星相向运动。当栈顶元素`stack[-1] > -ast` 行星发生爆炸，`alive=False`；当`stack[-1] <= -ast`，栈顶元素爆炸，需要出栈，重复以上判断，直到不满足条件。最后如果`alive = True`，则`ast`入栈

```python
class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        stack = []
        for ast in asteroids:
            alive = True
            while stack and stack[-1] > 0 and alive and ast < 0:
                alive = stack[-1] < -ast
                if stack[-1] <= -ast:
                    stack.pop()
            if alive:
                stack.append(ast)
        return stack
```



### 76 最小覆盖子串

思路：滑动窗口

滑动窗口经典例题

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        windows, need = defaultdict(int), defaultdict(int)
        for c in t:
            need[c] += 1
        
        left, right = 0, 0
        valid = 0
        # 记录最小覆盖子串的起始索引和长度
        start, length = 0, inf
        while right < len(s):
            c = s[right]
            right += 1
            # 进行窗口内的更新
            if c in need:
                windows[c] += 1
                if windows[c] == need[c]:
                    valid += 1

            # 判断左窗口是否要收缩
            while valid == len(need):
                # 在这里更新最小覆盖子串
                if right - left < length:
                    start = left
                    length = right - left
                d = s[left]
                left += 1
                if d in need:
                    if windows[d] == need[d]:
                        valid -= 1
                    windows[d] -= 1
                    
        return "" if length == inf else s[start: start + length]
```



### 567 字符串的排列

思路：滑动窗口

```python
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        windows, need = defaultdict(int), defaultdict(int)
        for c in s1:
            need[c] += 1
        left, right = 0, 0
        valid = 0
        while right < len(s2):
            c = s2[right]
            right += 1
            if c in need:
                windows[c] += 1
                if windows[c] == need[c]:
                    valid += 1
            # 判断是否左窗口是否要收缩
            while right - left >= len(s1):
                # 判断是否找到了合法的子串
                if valid == len(need):
                    return True
                d = s2[left]
                left += 1
                if d in need:
                    if windows[d] == need[d]:
                        valid -= 1
                    windows[d] -= 1
        return False
```

> 注意：判断左窗口是否要收缩的条件，是`right - left >= len(s1)`；同样 合法子串的判断条件是`valid == len(need)`。
>
> 注意分辨判断条件。



### 438 找到字符串中所有字母异位词

思路：滑动窗口

```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        windows, need = defaultdict(int), defaultdict(int)
        for c in p:
            need[c] += 1
        left, right = 0, 0
        valid = 0
        ans = []
        while right < len(s):
            c = s[right]
            right += 1
            if c in need:
                windows[c] += 1
                if windows[c] == need[c]:
                    valid += 1
            
            while right - left >= len(p):
                if valid == len(need):
                    ans.append(left)
                d = s[left]
                left += 1
                if d in need:
                    if windows[d] == need[d]:
                        valid -= 1
                    windows[d] -= 1
        return ans
```



## 22.07.14

### 745 前缀和后缀搜索

思路一：哈希暴力

将所有的前缀和后族组合都存入字典，键值为单词索引

```python
class WordFilter:

    def __init__(self, words: List[str]):
        self.map = {}
        for i, word in enumerate(words):
            m = len(word)
            for j in range(1, m + 1):
                for k in range(1, m + 1):
                    self.map[(word[:j], word[-k:])] = i

    def f(self, pref: str, suff: str) -> int:
        return self.map.get((pref, suff), -1)
```

思路二：字典树

这道题是典型字典树应用题。

但是可以不用分别建立前缀树和后缀树，这样虽然判断迅速，但是构建两个树的用时过高了

只需要建立一个前缀树，然后找到以`prefix`作为前缀的单词后，判断后缀是否为`suff`即可。

然后可以用备忘录，记录缓存。

```python
class TrieNode:
    def __init__(self):
        self.string = list()
        self.next = defaultdict(TrieNode)

class Trie:
    def __init__(self):
        self.root = TrieNode()
        
    def add(self, word, index):
        cur = self.root
        for c in word:
            cur = cur.next[c]
            cur.string.append(index)
    
    def search(self, word):
        cur = self.root
        for c in word:
            if c in cur.next:
                cur = cur.next[c]
            else:
                return []
        return cur.string


class WordFilter:

    def __init__(self, words: List[str]):
        self.prefTrie = Trie()
        self.words = words
        for idx, word in enumerate(words):
            self.prefTrie.add(word, idx)
        # 手动记录缓存
        self.memo = {}        

    def f(self, pref: str, suff: str) -> int:
        key = (pref, suff)
        if key in self.memo:
            return self.memo[key]
        for idx in reversed(self.prefTrie.search(pref)):
            if self.words[idx].endswith(suff):
                self.memo[key] = idx 
                return idx
        self.memo[key] = -1
        return -1
```



## 22.07.17

### 565 数组嵌套

思路：图遍历

```python
class Solution:
    def arrayNesting(self, nums: List[int]) -> int:
        ans, n = 0, len(nums)
        for i in range(n):
            cnt = 0
            while nums[i] < n:
                num = nums[i]
                nums[i] = n
                i = num
                cnt += 1
            ans = max(cnt, ans)
        return ans
```



## 22.07.19

### 731 我的日程安排表2

思路一：直接遍历

用 `overlaps` 保存有两段日程的时间段。当有新的预约时，先跟`overlaps`中的时间段相比，如果有重复覆盖即`s < end and start < e`，那么直接判断有三重安排。

如果没有，则把重复时间段加入`overlaps`，重复时间段为`(max(s, start), min(e, end))`

```python
class MyCalendarTwo:

    def __init__(self):
        self.booked = []
        self.overlaps = []


    def book(self, start: int, end: int) -> bool:
        if any(s < end and start < e for s, e in self.overlaps):
            return False
        for s, e in self.booked:
            if s < end and start < e:
                self.overlaps.append((max(s, start), min(e, end)))
        self.booked.append((start, end))
        return True
```



思路二：线段树

```python
class MyCalendarTwo:

    def __init__(self):
        self.tree = {}

    def update(self, start, end, val, l, r, idx):
        if r < start or end < l:
            return 
        if start <= l and r <= end:
            p = self.tree.get(idx, [0, 0])
            p[0] += val
            p[1] += val
            self.tree[idx] = p
            return 
        mid = (l + r) // 2
        self.update(start, end, val, l, mid, 2 * idx)
        self.update(start, end, val, mid + 1, r, 2 * idx + 1)
        p = self.tree.get(idx, [0,0])
        p[0] = p[1] + max(self.tree.get(2 * idx, (0, ))[0], self.tree.get(2 * idx + 1, (0,))[0])
        self.tree[idx] = p

    def book(self, start: int, end: int) -> bool:
        self.update(start, end - 1, 1, 0, 10 **9, 1)
        if self.tree[1][0] > 2:
            self.update(start, end - 1, -1, 0, 10 **9, 1)
            return False
        return True
```



## 22.07.20

### 1260 二维数组迁移

思路一：模拟

```python
class Solution:
    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        res = grid
        for _ in range(k):
            res = self.motify(res, len(res), len(res[0]))
        return res
    
    def motify(self, grid, m, n):
        c = [[0] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if i == 0 and j == 0:
                    c[i][j] = grid[m - 1][n -1]
                elif j == 0:
                    c[i][j] = grid[i - 1][n - 1]
                else:
                    c[i][j] = grid[i][j - 1]
        return c
```

思路二：一维展开

原来的(i, j)(i,j)对应的一维坐标为`i * n + j`,
向右平移kk后为`i * n + j + k`,
总共只有`m * n`个位置所以最终坐标为`(i * n + j + k) % (m * n)`,
转换回二维坐标即可。

```python
class Solution:
    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        k %= m * n
        ans = [[0] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                x, y = divmod(i * n + j + k, n)
                ans[x % m][y] = grid[i][j]
        return ans
```



## 22.07.21

### 874 二叉树剪枝

思路：后序遍历

使用后序遍历，自下往上判断每个叶子节点是否是0，是否要删除，递归即可。

```python
class Solution:
    def pruneTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if root is None:
            return None
        root.left = self.pruneTree(root.left)
        root.right = self.pruneTree(root.right)
        if not root.left and not root.right and root.val == 0  :
            return None
        return root
```

> 注意：递归的结果直接给左节点和右节点即可，不然没有在原二叉树上修改，没法得到正确结果



## 22.07.25

### 919 完全二叉树插入器

思路：层序遍历 + 队列

```python
from collections import deque
class CBTInserter:

    def __init__(self, root: TreeNode):
        self.root = root
        self.queue = deque([])
        # BFS
        temp = deque([root])
        while temp:
            cur = temp.popleft()
            if not cur.left or not cur.right:
                self.queue.append(cur)
            if cur.left:
                temp.append(cur.left)
            if cur.right:
                temp.append(cur.right)


    def insert(self, val: int) -> int:
        node = TreeNode(val)
        cur = self.queue[0]
        if not cur.left:
            cur.left = node
        elif not cur.right:
            cur.right = node
            self.queue.popleft()
        self.queue.append(node)
        return cur.val


    def get_root(self) -> TreeNode:
        return self.root
```



### 102 二叉树的层序遍历

思路：BFS 层序遍历

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        ans = []
        while queue:
            ans.append([node.val for node in queue])
            child = []
            for node in queue:
                if node.left:
                    child.append(node.left)
                if node.right:
                    child.append(node.right)
            queue = child
        return ans
```



## 22.07.26

### 1206 设计跳表

```python
MAX_LEVEL = 32
P_FACTOR = 0.25

def random_level():
    lv = 1
    while lv < MAX_LEVEL and random.random() < P_FACTOR:
        lv += 1
    return lv

class SkiplistNode:
    __slots__ = 'val', 'forward'

    def __init__(self, val, max_level=MAX_LEVEL):
        self.val = val
        self.forward = [None] * max_level

class Skiplist:

    def __init__(self):
        self.head = SkiplistNode(-1)
        self.level = 0

    def search(self, target: int) -> bool:
        cur = self.head
        for i in range(self.level - 1, -1, -1):
            # 找到第i层小于且最接近 target 的元素
            while cur.forward[i] and cur.forward[i].val < target:
                cur = cur.forward[i]
        cur = cur.forward[i]
        # 检测当前元素的值是否等于 target
        return cur is not None and cur.val == target

    def add(self, num: int) -> None:
        update = [self.head] * MAX_LEVEL
        cur = self.head
        for i in range(self.level - 1, -1, -1):
            # 找到第i层小于且最接近 num 的元素
            while cur.forward[i] and cur.forward[i].val < num:
                cur = cur.forward[i]
            update[i] = cur
        lv = random_level()
        self.level = max(self.level, lv)
        new_node = SkiplistNode(num, lv)
        for i in range(lv):
            # 对第 i 层的状态进行更新，将当前元素的forward指向新节点
            new_node.forward[i] = update[i].forward[i]
            update[i].forward[i] = new_node

    def erase(self, num: int) -> bool:
        update = [None] * MAX_LEVEL
        cur = self.head
        for i in range(self.level - 1, -1, -1):
            # 找到第i层小于且最接近 num 的元素
            while cur.forward[i] and cur.forward[i].val < num:
                cur = cur.forward[i]
            update[i] = cur
        cur = cur.forward[0]
        if cur is None or cur.val != num:    # 值不存在
            return False
        for i in range(self.level):
            if update[i].forward[i] != cur:
                break
            # 对第 i 层的状态进行更新，将 forward 指向被删除节点的下一节点
            update[i].forward[i] = cur.forward[i]
        # 更新当前的level
        while self.level < 1 and self.head.forward[self.level - 1] is None:
            self.level -= 1
        return True
```



## 22.07.27

### 592 分数加减运算

思路：模拟

**关键在于如何依次读取分子与分母**

> 分子为 0 时，可以直接输出 '0/1' ，会节省不少时间

```python
class Solution:
    def fractionAddition(self, expression: str) -> str:
        denominator, numerator = 0, 1    # 分子， 分母
        i, n = 0, len(expression)
        while i < n:
            # 读取分子
            denominator1, sign = 0, 1
            if expression[i] in ['+','-']:
                if expression[i] == '-':
                    sign = -1
                i += 1
            while i < n and expression[i].isdigit():
                denominator1 = denominator1 * 10 + int(expression[i])
                i += 1
            denominator1 = sign * denominator1
            i += 1

            # 读取分母
            numerator1 = 0
            while i < n and expression[i].isdigit():
                numerator1 = numerator1 * 10 + int(expression[i])
                i += 1
            
            denominator = denominator * numerator1 + denominator1 * numerator
            numerator *= numerator1
        if denominator == 0:
            return '0/1'
        g = gcd(abs(denominator), numerator)
        return f"{denominator // g}/{numerator // g}"
```

利用每一项分子或者分母都在`0-9`之间，可以直接对每一位进行判断，然后分别将分子分母存入 `nums` 中。然后对分母求最小公倍数，对分子求膨胀分子和。最后求最大公约数后进行化简。

```python
class Solution:
    def fractionAddition(self, expression: str) -> str:
        # 遍历字符串将每个项的分子分母依次加入数组
        n = len(expression)
        nums = []
        cur = expression[0]
        i = 1
        while i < n:
            if expression[i] == '/':
                nums.append(int(cur))
                cur = ""
            elif expression[i] in ['+', '-']:
                nums.append(int(cur))
                cur = expression[i]
            else:
                cur += expression[i]
            i += 1
        nums.append(int(cur))

        # 奇数项为分母 遍历求最小公倍数
        m = len(nums)
        denominator = 1
        for i in range(1, m, 2):
            denominator = math.lcm(denominator, nums[i])
        
        # 偶数项为分子 遍历计算膨胀分子加和
        numerator = 0
        for i in range(0, m, 2):
            numerator += nums[i] * denominator // nums[i + 1]
        if denominator == 0:
            return '0/1'

        # 求分子分母的最大公约数后化简
        factor = math.gcd(denominator, numerator)
        denominator //= factor
        numerator //= factor
        return f"{numerator}/{denominator}"
```



### 889 根据前序遍历和后序遍历结果构建二叉树

思路：递归

跟用前序（后序）遍历和中序遍历构建二叉树不同，这道题的结果是不一定的。

但是还是可以用相同的思路来写。

**在找左子树的序列长度的时候，可以通过根节点后一位元素，在后序遍历的位置来确定左子树长度。**

```python
class Solution:
    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> TreeNode:
        if not preorder:
            return None
        root = TreeNode(preorder[0])
        if len(preorder) == 1:
            return root
        L = postorder.index(preorder[1]) + 1
        root.left = self.constructFromPrePost(preorder[1:L + 1], postorder[:L])
        root.right = self.constructFromPrePost(preorder[L + 1:], postorder[L:-1])
        return root
```



### 104 二叉树的最大深度

思路一：动态规划 / 递归

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        leftmax = self.maxDepth(root.left)
        rightmax = self.maxDepth(root.right)
        return 1 + max(leftmax, rightmax)
```



思路二：回溯

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        depth, res = 0, 0
        
        # dfs 遍历二叉树
        def traverse(root):
            nonlocal res, depth
            if not root:
                return 
            # 前序遍历位置
            depth += 1
            # 遍历过程记录最大深度
            res = max(res, depth)
            traverse(root.left)
            traverse(root.right)
            # 后序遍历位置
            depth -= 1
        traverse(root)
        return res
```



### 111 二叉树的最小深度

思路：BFS 广度优先遍历

相比于DFS，BFS在没有遍历完一整颗树时就可能找到最小深度，但是DFS可能遍历完整的一棵树才能找到最浅深度，因此相比较而言，BFS会更快。

```python
from collections import deque
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root: return 0
        q = deque([root])
        depth = 1
        while q:
            for _ in range(len(q)):
                node = q.popleft()
                if not node.left and not node.right:
                    return depth
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            depth += 1
        return depth
```



### 752 打开密码锁

思路：BFS

labuladong python写法：超时

```python
class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:
        if target == '0000':
            return 0
        dead = set(deadends)
        if '0000' in dead:
            return -1
            
        q = deque(['0000'])
        visited = ['0000']

        step = 0
        while q:
            n = len(q)
            for _ in range(n):
                cur = q.popleft()
                # 判断密码是否合法
                if cur in deadends:
                    continue
                # 判断是否找到target
                if cur == target:
                    return step
                # 将一个节点的未遍历相邻接点加入队列
                for j in range(4):
                    up = self.plusOne(cur, j)
                    if up not in visited:
                        q.append(up)
                        visited.append(up)
                    down = self.minusOne(cur, j)
                    if down not in visited:
                        q.append(down)
                        visited.append(down)
            step += 1
        return -1

    def plusOne(self, s, j):
        c = ''
        for i in range(len(s)):
            if i != j:
                c += s[i]
            else:
                c += '0' if s[i] == '9' else str(int(s[j]) + 1)
        return c
    
    def minusOne(self, s, j):
        c = ''
        for i in range(len(s)):
            if i != j:
                c += s[i]
            else:
                c += '9' if s[i] == '0' else str(int(s[j]) - 1)
        return c
```

labuladong java写法：不超时

```java
class Solution {
    String plusOne(String s, int j){
        char[] ch = s.toCharArray();
        if (ch[j] == '9')
            ch[j] = '0';
        else
            ch[j] += 1;
        return new String(ch);
    }

    String minusOne(String s, int j){
        char[] ch = s.toCharArray();
        if (ch[j] == '0')
            ch[j] = '9';
        else
            ch[j] -= 1;
        return new String(ch);
    }

    public int openLock(String[] deadends, String target) {
        // 记录需要跳过的死亡密码
        Set<String> deads = new HashSet<>();
        for ( String s : deadends) deads.add(s);
        // 记录已经穷举过的密码
        Set<String> visited = new HashSet<>();
        Queue<String> q = new LinkedList<>();
        // 从起点开始启动广度优先搜索
        int step = 0;
        q.offer("0000");
        visited.add("0000");

        while (!q.isEmpty()){
            int sz = q.size();
            for (int i = 0; i < sz; i++){
                String cur = q.poll();

                /*判断密码是否合法，是否到达终点*/
                if (deads.contains(cur))
                    continue;
                if (cur.equals(target))
                    return step;
                /*将一个节点的未遍历相邻接点加入队列 */
                for (int j = 0; j < 4; j++){
                    String up = plusOne(cur, j);
                    if (!visited.contains(up)){
                        q.offer(up);
                        visited.add(up);
                    }
                    String down = minusOne(cur, j);
                    if (!visited.contains(down)){
                        q.offer(down);
                        visited.add(down);
                    }
                }
            }
            step++;
        }
        return -1;
    }
}
```

官方题解：

```python
class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:
        if target == '0000':
            return 0
        dead = set(deadends)
        if '0000' in dead:
            return -1

        def num_prev(x):
            return '9' if x == '0' else str(int(x) - 1)
        
        def num_succ(x):
            return '0' if x == '9' else str(int(x) + 1)
        
        def get(status):
            s = list(status)
            for i in range(4):
                num = s[i]
                s[i] = num_prev(num)
                yield ''.join(s)
                s[i] = num_succ(num)
                yield ''.join(s)
                s[i] = num

        q = deque([('0000', 0)])
        visited = {'0000'}
        while q:
            status, step = q.popleft()
            for next_status in get(status):
                if next_status not in visited and next_status not in dead:
                    if next_status == target:
                        return step + 1
                    q.append((next_status, step + 1))
                    visited.add(next_status)
        return -1
```

思路二：双向BFS

```java
class Solution {
    String plusOne(String s, int j){
        char[] ch = s.toCharArray();
        if (ch[j] == '9')
            ch[j] = '0';
        else
            ch[j] += 1;
        return new String(ch);
    }

    String minusOne(String s, int j){
        char[] ch = s.toCharArray();
        if (ch[j] == '0')
            ch[j] = '9';
        else
            ch[j] -= 1;
        return new String(ch);
    }

    public int openLock(String[] deadends, String target) {
        // 记录需要跳过的死亡密码
        Set<String> deads = new HashSet<>();
        for ( String s : deadends) deads.add(s);
        // 记录已经穷举过的密码
        Set<String> visited = new HashSet<>();
        // 用集合不用队列，可以快速判断元素是否存在
        Set<String> q1 = new HashSet<>();
        Set<String> q2 = new HashSet<>();
        // 初始化起点和终点
        int step = 0;
        q1.add("0000");
        q2.add(target);

        while (!q1.isEmpty() && !q2.isEmpty()){
            // 在遍历的过程中，不能修改哈希集合
            // 用 temp 存储 q1 的扩散结果
            Set<String> temp = new HashSet<>();
            
            /**将 q1 中的所有节点向周围扩散 */
            for (String cur : q1){
                /*判断密码是否合法，是否到达终点*/
                if (deads.contains(cur))
                    continue;
                if (q2.contains(cur))
                    return step;

                visited.add(cur);
                /*将一个节点的未遍历相邻接点加入队列 */
                for (int j = 0; j < 4; j++){
                    String up = plusOne(cur, j);
                    if (!visited.contains(up))
                        temp.add(up);
                    String down = minusOne(cur, j);
                    if (!visited.contains(down))
                        temp.add(down);
                }
            }
            step++;
            // temp 相当于 q1
            // 在这里交换q1 和 q2 ，下轮会扩散q2
            q1 = q2;
            q2 = temp;
        }
        return -1;
    }
}
```



## 22.07.28

### 1331 数组序号转换

思路：去重 +排序 + 哈希

**使用哈希找索引的速度会快很多，不要用 `.index()`方法，会超时！**

```python
class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        ranks = {v : i for i, v in enumerate(sorted(set(arr)), 1)}
        return [ranks[v] for v in arr]
```

