# 刷题日记

## 2022.07.07

### LeetCode23 合并k个有序链表

思路一：堆

python中只有最小堆

可以将所有的节点值都直接放入堆中，然后依次取出链接但是这样的空间复杂度会高O(KN)。

```python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        import heapq
        
        if not lists: return None
        minheap = []
        for item in lists:
            while item:
                heapq.heappush(minheap, item.val)
                item = item.next
        pre = ListNode(-1)
        cur = pre
        while minheap:
            cur.next = ListNode(heapq.heappop(minheap))
            cur = cur.next
        return pre.next
```

空间复杂度优化：创建只有lists.length长度的堆，每次取出最小的节点后，再放入新的节点。

```python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        import heapq
        ListNode.__lt__ = lambda a, b: 0
        if not lists: return None
        nodeheap = []
        for node in lists:
            if node:
                heapq.heappush(nodeheap, (node.val, node))
        dummy = ListNode(-1)
        cur = dummy

        while nodeheap:
            val, node = heapq.heappop(nodeheap)
            cur.next = ListNode(val)
            cur = cur.next
            if node.next:
                heapq.heappush(nodeheap, (node.next.val, node.next))
        return dummy.next
```

### LeetCode648 单词替换

思路一：哈希

```python
class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        dictionarySet = set(dictionary)
        words = sentence.split(' ')
        for i, word in enumerate(words):
            for j in range(1, len(words) + 1):
                if word[:j] in dictionarySet:
                    words[i] = word[:j]
                    break
        return ' '.join(words)
```

思路二：字典树

根据题目给的**前缀(词根)创建字典树**，遍历句子中的每个单词，替换为第一个与字典树匹配的前缀。
与其他题目的Trie树的搜索用法不同的是，**我们不需要保证整个单词属于字典树中或整个单词可以拆解成字典树中的单词**，只需要找到第一次匹配到的前缀即可，所以这里写了一个新的查询方法。

```python
class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        trie = Trie()
        for d in dictionary:
            trie.insert(d)
        words = sentence.split(' ')
        return ' '.join(trie.find_sp(word) for word in words) 

class Trie:
    def __init__(self):
        self.root = {}

    def insert(self, word):
        node = self.root
        for w in word + "#":
            if w not in node:
                node[w] = {}
            node = node[w]
    
    def find(self, word):
        node = self.root
        for i in range(len(word)):
            if '#' in node:
                if self.find(word[i:]):
                    return True
            if word[i] in node:
                node = node[word[i]]
            else:
                return False
        return '#' in node

    def find_sp(self, word):
        node = self.root
        for i in range(len(word)):
            if "#" in node:
                return word[:i]
            if word[i] in node:
                node = node[word[i]]
            else:
                break
        return word
```
