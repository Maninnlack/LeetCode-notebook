# 刷题日记

## **22.07.07**

### 23 合并k个有序链表

思路一：堆

python中只有最小堆

可以将所有的节点值都直接放入堆中，然后依次取出链接但是这样的空间复杂度会高O(KN)。

```python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        import heapq

        if not lists: return None
        minheap = []
        for item in lists:
            while item:
                heapq.heappush(minheap, item.val)
                item = item.next
        pre = ListNode(-1)
        cur = pre
        while minheap:
            cur.next = ListNode(heapq.heappop(minheap))
            cur = cur.next
        return pre.next
```

空间复杂度优化：创建只有lists.length长度的堆，每次取出最小的节点后，再放入新的节点。

```python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        import heapq
        ListNode.__lt__ = lambda a, b: 0
        if not lists: return None
        nodeheap = []
        for node in lists:
            if node:
                heapq.heappush(nodeheap, (node.val, node))
        dummy = ListNode(-1)
        cur = dummy

        while nodeheap:
            val, node = heapq.heappop(nodeheap)
            cur.next = ListNode(val)
            cur = cur.next
            if node.next:
                heapq.heappush(nodeheap, (node.next.val, node.next))
        return dummy.next
```

思路二：归并法：

```python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        if not lists: return None
        res = self.mergesort(lists, 0, len(lists) - 1)
        return res

    # 边界值的定义要清晰，这里是两边都闭区间
    def mergesort(self, lists, l, r):
        if l == r:
            return lists[l]
        m = (l + r) // 2
        left = self.mergesort(lists, l, m)
        right = self.mergesort(lists, m + 1, r)
        return self.merge(left, right)

    def merge(self, l1, l2):
        pre = ListNode(-1)
        cur = pre
        while l1 and l2:
            if l1.val <= l2.val:
                cur.next = l1
                l1 = l1.next
            else:
                cur.next = l2
                l2 = l2.next
            cur = cur.next
        cur.next = l1 if l1 else l2
        return pre.next
```

### 648 单词替换

思路一：哈希

```python
class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        dictionarySet = set(dictionary)
        words = sentence.split(' ')
        for i, word in enumerate(words):
            for j in range(1, len(words) + 1):
                if word[:j] in dictionarySet:
                    words[i] = word[:j]
                    break
        return ' '.join(words)
```

思路二：字典树

根据题目给的**前缀(词根)创建字典树**，遍历句子中的每个单词，替换为第一个与字典树匹配的前缀。
与其他题目的Trie树的搜索用法不同的是，**我们不需要保证整个单词属于字典树中或整个单词可以拆解成字典树中的单词**，只需要找到第一次匹配到的前缀即可，所以这里写了一个新的查询方法。

```python
class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        trie = Trie()
        for d in dictionary:
            trie.insert(d)
        words = sentence.split(' ')
        return ' '.join(trie.find_sp(word) for word in words) 

class Trie:
    def __init__(self):
        self.root = {}

    def insert(self, word):
        node = self.root
        for w in word + "#":
            if w not in node:
                node[w] = {}
            node = node[w]

    def find(self, word):
        node = self.root
        for i in range(len(word)):
            if '#' in node:
                if self.find(word[i:]):
                    return True
            if word[i] in node:
                node = node[word[i]]
            else:
                return False
        return '#' in node

    def find_sp(self, word):
        node = self.root
        for i in range(len(word)):
            if "#" in node:
                return word[:i]
            if word[i] in node:
                node = node[word[i]]
            else:
                break
        return word
```

按照 labuladong 模板的写法：

```python
class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        # 建立前缀树 并把 dictionary 中词根加入到 trie 中
        trie = Trie()
        for d in dictionary:
            trie.insert(d)
        words = sentence.split(' ')
        for i in range(len(words)):
            prefix = trie.shortestPrefix(words[i])
            # 如果找到了最短前缀就用 prefix 替换
            if prefix:
                words[i] = prefix
        return ' '.join(words)

class Node:
    def __init__(self):
        self.children = collections.defaultdict(Node)
        self.isword = False

class Trie:
    def __init__(self):
        self.root = Node()

    def insert(self, word):
        node = self.root
        for w in word:
            node = node.children[w]
        node.isword = True

    def find(self, word):
        node = self.root
        for w in word:
            node = node.children.get(w)
            if node == None:
                return False
        return node.isword

    # 在所有键中找到 word 的最短前缀
    def shortestPrefix(self, word):
        node = self.root
        for i in range(len(word)):
            # 无法继续向下搜索
            if node == None:
                return ""
            # 找到一个键是 word 的前缀
            if node.isword:
                return word[:i]
            # 向下搜索
            node = node.children.get(word[i])
        # 如果 word 本身就是一个键
        if node and node.isword:
            return word
        return ""
```

## **22.07.08**

### 208 实现前缀树

这里只需要insert search startswith几个函数即可

```python
class Node:
    def __init__(self):
        self.children = collections.defaultdict(Node)
        self.isword = False

class Trie:

    def __init__(self):
        self.root = Node()

    def insert(self, word: str) -> None:
        node = self.root
        for w in word:
            node = node.children[w]
        node.isword = True

    def search(self, word: str) -> bool:
        node = self.root
        for w in word:
            node = node.children.get(w)
            if node == None:
                return False
        return node.isword

    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for w in prefix:
            node = node.children.get(w)
            if node == None: return False
        return True
```

### 211 添加查找单词

思路一：字典树

负雪明烛方法一：（超时）

```python
class Node:
    def __init__(self):
        self.children = collections.defaultdict(Node)
        self.isEnd = False

class WordDictionary(object):

    def __init__(self):
        self.root = Node()

    def addWord(self, word):
        node = self.root
        for w in word:
            node = node.children[w]
        node.isEnd = True

    def search(self, word):
        return self.match(word, idx, self.root)

    def match(word, idx, root):
        if not root:
            return False
        if idx == len(word):
            return root.isEnd
        if word[idx] != '.':
            return root and self.match(word, idx + 1, root.children.get(word[idx]))
        else:
            for child in root.children.values():
                if self.match(word, idx + 1, child):
                    return True
        return False
```

Ben bfs方法：（不超时）

```python
class WordDictionary(object):

    def __init__(self):
        self.trie = dict()

    def addWord(self, word):
        node = self.trie
        for ch in word:
            if ch not in node:
                node[ch] = {}
            node = node[ch]
        node["#"] = {}

    def search(self, word):
        word += '#'
        bfs = deque([(0, self.trie)])
        while bfs:
            idx, cur = bfs.popleft()
            if idx == len(word):
                return True
            if word[idx] == '.':
                for nxt in cur.values():
                    bfs.append((idx + 1, nxt))
            elif word[idx] in cur:
                bfs.append((idx + 1, cur[word[idx]]))
        return False
```

官方标准字典树模板：（不超时）

```python
class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.isEnd = False

    def insert(self, word):
        node = self
        for ch in word:
            ch = ord(ch) - ord('a')
            if not node.children[ch]:
                node.children[ch] = TrieNode()
            node = node.children[ch]
        node.isEnd = True


class WordDictionary:

    def __init__(self):
        self.trieRoot = TrieNode()

    def addWord(self, word: str) -> None:
        self.trieRoot.insert(word)

    def search(self, word: str) -> bool:

        def dfs(index, node):
            if index == len(word):
                return node.isEnd
            ch = word[index]

            if ch != '.':
                child = node.children[ord(ch) - ord('a')]
                if child is not None and dfs(index + 1, child):
                    return True
            else:
                for child in node.children:
                    if child is not None and dfs(index + 1, child):
                        return True
            return False

        return dfs(0, self.trieRoot)
```

思路二：哈希字典（单词长度作为键值）（超时）

```python
class WordDictionary:

    def __init__(self):
        self.words = collections.defaultdict(list)

    def addWord(self, word: str) -> None:
        self.words[len(word)] += [word]

    def search(self, word: str) -> bool:
        n = len(word)

        def f(s):
            for i in range(n):
                if word[i] not in {s[i], '.'}:
                    return False
            return True

        for s in self.words[n]:
            if f(s):
                return True
        return False
```

### 677 键值映射

思路一：字典树

不再是TrieSet，而是要记录value值的TrieMap

```python
class MapSum:

    def __init__(self):
        self.root = {}

    def insert(self, key: str, val: int) -> None:
        node = self.root
        for c in key:
            if c not in node:
                node[c] ={}
            node = node[c]
        node['val'] = val

    def sum(self, prefix: str) -> int:
        node = self.root
        for c in prefix:
            if c not in node:
                return 0
            node = node[c]
        ans = 0
        def dfs(node):
            for c in node:
                if c == 'val':
                    nonlocal ans
                    ans += node[c]
                else:
                    dfs(node[c])
        dfs(node)
        return ans
```

思路二：暴力法

使用内置的 startswith 函数进行判断。

```python
class MapSum:

    def __init__(self):
        self.dict = {}

    def insert(self, key: str, val: int) -> None:
        self.dict[key] = val

    def sum(self, prefix: str) -> int:
        res = 0
        for k, v in self.dict.items():
            if k.startswith(prefix):
                res += v
        return res
```

### 1217 玩筹码

思路：贪心

比较奇数和偶数位置数量的最小值即可。

```python
class Solution:
    def minCostToMoveChips(self, position: List[int]) -> int:
        cnt = Counter(p % 2 for p in position) ## 根据模 2 后的余数来统计奇偶个数
        return min(cnt[0], cnt[1])
```

## 22.07.09

### 873 最长斐波那契子序列长度

思路：经典动态规划应用问题

dp函数定义：`dp[j][i]`定义为以`arr[j]` 和 `arr[i]`作为结尾的最长斐波那契子序列长度。为了计算`dp[j][i]`的值需要得到该斐波那契序列 `arr[j]`前面一个数字，命名为 `arr[k]`。由于arr 是严格单调递增的，所以有 `k < j < i` 。由斐波那契数列的定义可以知道，斐波那契子序列的最小长度为3，因此状态转移方程可以写为：
$$
dp[j][i]=\left\{
\begin{aligned}
max(3,~ dp[k][j] + 1),  & 0 < k < j \\
0,  & k < 0~or~k > j
\end{aligned}
\right.
$$
同时可以进行一部分优化，由于arr 是严格单调递增的，只有当` arr[i] - arr[j] >= arr[j]`， 也即 `arr[i] >= arr[j] * 2`时才寻找k。

```python
class Solution:
    def lenLongestFibSubseq(self, arr: List[int]) -> int:
        n, idx_map, ans = len(arr), {x : i for i, x in enumerate(arr)}, 0
        dp = [[0] * n for _ in range(n)]
        for i in range(n):
            for j in range(n - 1, -1, -1):
                if arr[i] - arr[j] >= arr[j]: break
                if arr[i] - arr[j] in idx_map:
                    k = idx_map[arr[i] - arr[j]]
                    dp[j][i] = max(3, dp[k][j] + 1)
                    ans = max(ans, dp[j][i])
        return ans
```

benhao使用哈希对空间进行优化，因为使用dp数组会有一半的空间浪费

```python
class Solution:
    def lenLongestFibSubseq(self, arr: List[int]) -> int:
        # 初始化 n=数组长度  用ind_map记录元素出现的下标（严格递增不重复）
        n, idx_map, ans = len(arr), {x : i for i, x in enumerate(arr)}, 0
        # 根据hash索引 得到一个 新的hash表，其中的任何键的初始值都为2
        dp = defaultdict(lambda: defaultdict(lambda: 2))
        # 二重循环遍历 根据fib前两项 寻找是否存在 满足条件的第三项
        for i in range(n - 1):
            for j in range(i + 1, n):
                # 以i,j为fib前两项 并在数组中能够找到符合条件的最后一项

                # dp的初始值只包含i和j这两项 
                # 找到第三项后，以j,nxt结尾的子序列长度加上“i”这一项
                if (nxt := arr[i] + arr[j]) in idx_map:
                    dp[j][idx_map[nxt]] = dp[i][j] + 1
                    ans = max(ans, dp[j][idx_map[nxt]])
        return ans
```

## 22.07.10

### 741 摘樱桃

思路：动态规划

从（0,0）到（N-1，N-1），再从（N-1，N-1）到（0,0）。可以视为两个人同时从（0,0）走到（N-1，N-1）。但是要限制两个人走到同一个格子时，只能摘一个樱桃。

对于两个人位置的描述，可以只用三个参数即可。假设两个人的初始位置相同且速度相同，那么不论两个人怎么走，两个人的步数都是相同的（设为k）。这时如果两个人的坐标分别为 (x1, y1) 和 (x2, y2) ，那么有 `x1 + y1 = x2 + y2 = k`，所以A B两个人的位置可以表示为 (x1, k - x1) 和 (x2, k - x2)。那么当 `x1 = x2`时，两个人的位置肯定是相同的。

定义状态函数 `dp[k][x1][x2]` 表示为 两个人分别从（x1, k - x1） 和 (x2, k - x2) 出发到达（N-1，N-1）时，摘到的樱桃个数之和的最大值。

如果（x1, k - x1） 或 (x2, k - x2)  是荆棘，则 `dp[k][x1][x2] = -inf`

那么A B 从上一步走过来的情况一共有四种，分别为：

- 都往右：从`dp[k-1][x1][x2]`来
- A往下，B往右：从`dp[k-1][x1-1][x2]`来
- A往右，B往下：从`dp[k-1][x1][x2-1]`来
- 都往下：从`dp[k-1][x1-1][x2-1]`来

取这四种情况的最大值，再加上`grid[x1][k-x1]` 和 `grid[x2][k-x2]`的值，就得到了`dp[k][x1][x2]`，如果`x1 = x2`，那么只用加上`grid[x1][k-x1]`的值。

最后的答案为`max(dp[2n-2][n-1][n-1], 0)`，跟0取max是因为可能存在所有路都被荆棘挡住的情况。

```python
class Solution:
    def cherryPickup(self, grid: List[List[int]]) -> int:
        n = len(grid)
        dp = [[[-inf] * n for _ in range(n)] for _ in range(n * 2 - 1)]
        dp[0][0][0] = grid[0][0]
        for k in range(1, n * 2 - 1):
            for x1 in range(max(k - n + 1, 0), min(k + 1, n)):
                y1 = k - x1
                if grid[x1][y1] == -1:
                    continue
                for x2 in range(x1, min(k + 1, n)):
                    y2 = k - x2
                    if grid[x2][y2] == -1:
                        continue
                    res = dp[k - 1][x1][x2] # 都往右
                    if x1:
                        res = max(res, dp[k - 1][x1 - 1][x2]) # 往下， 往右
                    if x2:
                        res = max(res, dp[k - 1][x1][x2 - 1]) # 往右，往下
                    if x1 and x2:
                        res = max(res, dp[k - 1][x1 - 1][x2 - 1]) # 都往下
                    res += grid[x1][y1]
                    if x2 != x1:    # 避免重复摘同一个樱桃
                        res += grid[x2][y2]
                    dp[k][x1][x2] = res
        return max(dp[-1][-1][-1], 0)
```

## 22.07.11

### 676 实现一个魔法字典

**思路一：模拟**

将字典中的单词按照单词长度存入字典，然后搜索的时候遍历 `searchword`长度的即可

自己写的超级笨比写法：

```python
class MagicDictionary:

    def __init__(self):
        self.dic = defaultdict(list)

    def buildDict(self, dictionary: List[str]) -> None:
        for i in range(len(dictionary)):
            self.dic[len(dictionary[i])] += [dictionary[i]]

    def search(self, searchWord: str) -> bool:
        n = len(searchWord)
        if n not in self.dic:
            return False
        ans = [False] * len(self.dic[n])
        for i in range(len(self.dic[n])):
            if self.diff(self.dic[n][i], searchWord) == 1:
                ans[i] = True
        return True in ans


    def diff(self, s1, s2):
        ans = 0
        n = len(s1)
        for i in range(n):
            if s1[i] != s2[i]:
                ans += 1
        return ans
```

benhao大佬的简介写法：

```python
class MagicDictionary:

    def __init__(self):
        self.dic = defaultdict(list)

    def buildDict(self, dictionary: List[str]) -> None:
        for d in dictionary:
            self.dic[len(d)].append(d)

    def search(self, searchWord: str) -> bool:
        for d in self.dic[len(searchWord)]:
            if sum(c0 != c1 for c0, c1 in zip(searchWord, d)) == 1:
                return True
        return False
```

我怎么就没有想到直接用zip组合 然后直接判断呢，还多写了一个函数，对比一下，发现自己的方法太笨了

**思路二：字典树**

我们也可以使用字典树代替数组，将所有字符串进行存储。

在查询时，我们可以使用递归 + 回溯的方法，使用递归函数`dfs(node, posmodified)`，其中的变量分别表示：当前遍历到的字典树上的节点是 `node` 以及待查询字符串 `searchWord` 的第`pos` 个字符，并且在之前的遍历中是否已经替换过恰好一个字符（如果替换过，那么 `modified` 为true，否则为  false）。

如果`node` 有一个值为 `searchWord[pos]` 的子节点，那么我们就可以继续进行递归。同时，如果`modified` 为`false`，我们可以将 `searchWord[pos]`替换成任意一个是 `node` 子节点的字符，将 `modified` 置为`true` 并继续进行递归。

当`pos` 等于`searchWord` 的长度时，说明递归完成。此时我们需要检查`node` 是否是一个字典树上的结束节点（即一个单词的末尾），同时需要保证 `modified` 为 `true`，因为我们必须进行一次修改。

```python
class Trie:
    def __init__(self):
        self.is_finished = False
        self.child = dict()

class MagicDictionary:

    def __init__(self):
        self.root = Trie()

    def buildDict(self, dictionary: List[str]) -> None:
        for word in dictionary:
            cur = self.root
            for ch in word:
                if ch not in cur.child:
                    cur.child[ch] = Trie()
                cur = cur.child[ch]
            cur.is_finished = True

    def search(self, searchWord: str) -> bool:
        def dfs(node: Trie, pos:int, modified:bool):
            if pos == len(searchWord):
                return modified and node.is_finished

            ch = searchWord[pos]
            if ch in node.child:
                if dfs(node.child[ch], pos + 1, modified):
                    return True

            if not modified:
                for cnext in node.child:
                    if ch != cnext:
                        if dfs(node.child[cnext], pos + 1, True):
                            return True
            return False

        return dfs(self.root, 0, False)
```

### 1 两数之和

思路一：暴力遍历

暴力遍历的时间复杂度是O(N^2)，但是居然没有超时。不过我看我两年前的暴力遍历测试用时很短，现在已经很长了。

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums) - 1):
            for j in range(i + 1, len(nums)):
                if nums[i] + nums[j] == target:
                    return i, j
```

思路二：哈希

将所有数的值-索引 存到字典中，然后查找每一个`target -num`是否在字典中，并且是否是原来那个数。

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        index = {}
        for i in range(len(nums)):
            index[nums[i]] = i
        for i, num in enumerate(nums):
            j = index.get(target - num)
            if j is not None and i != j:
                return [i, j]
```



## 22.07.12

### 1252 奇数单元格的数目

思路：直接模拟

```python
class Solution:
    def oddCells(self, m: int, n: int, indices: List[List[int]]) -> int:
        matrix = [[0] * n for _ in range(m)]
        for r, c in indices:
            for i in range(n):
                matrix[r][i] += 1
            for row in matrix:
                row[c] += 1
        return sum(x % 2 for row in matrix for x in row)
```

`sum()`函数的使用不够熟练，要学会写成一行的简洁形式



### 1 两数相加

思路：模拟

```python
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        pre = ListNode(-1)
        cur = pre
        flag = 0
        while l1 or l2:
            x = l1.val if l1 else 0
            y = l2.val if l2 else 0
            sum = x + y + flag
            cur.next = ListNode(sum % 10)
            cur = cur.next
            flag = sum // 10
            if l1: l1 = l1.next
            if l2: l2 = l2.next
        if flag:
            cur.next = ListNode(1)
        return pre.next
```

> 思考：在循环的开始是就应该确认x，y的值，然后当遇到一个链表遍历至结尾，另一个还没结束时，取0，而不是在后面加节点，这样会导致无法跳出循环。
>
> 大致流程是没有问题的。但是在一些细节上的考虑还不够全面。



## 22.07.13

### 3 无重复的最长子串

思路：滑动窗口

这题是较为简单的滑动窗口题，仅需要统计窗口内字符的数量即可。

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        windows = defaultdict(int)
        left, right = 0, 0
        res = 0
        while right < len(s):
            c = s[right]
            right += 1
            windows[c] += 1
            while windows[c] > 1:
                d = s[left]
                left += 1
                windows[d] -= 1
            res = max(res, right - left)
        return res
```

> 要熟练滑动窗口的模板。



### 735 行星碰撞

思路：栈模拟

使用`stack`模拟行星碰撞，`alive`记录行星是否还存在，从左往右遍历 `asteriods`中的行星`ast`。

当 行星`ast`存在且`ast < 0`， 并且`stack` 非空且栈顶元素`stack[-1] > 0`，两个行星相向运动。当栈顶元素`stack[-1] > -ast` 行星发生爆炸，`alive=False`；当`stack[-1] <= -ast`，栈顶元素爆炸，需要出栈，重复以上判断，直到不满足条件。最后如果`alive = True`，则`ast`入栈

```python
class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        stack = []
        for ast in asteroids:
            alive = True
            while stack and stack[-1] > 0 and alive and ast < 0:
                alive = stack[-1] < -ast
                if stack[-1] <= -ast:
                    stack.pop()
            if alive:
                stack.append(ast)
        return stack
```



### 76 最小覆盖子串

思路：滑动窗口

滑动窗口经典例题

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        windows, need = defaultdict(int), defaultdict(int)
        for c in t:
            need[c] += 1
        
        left, right = 0, 0
        valid = 0
        # 记录最小覆盖子串的起始索引和长度
        start, length = 0, inf
        while right < len(s):
            c = s[right]
            right += 1
            # 进行窗口内的更新
            if c in need:
                windows[c] += 1
                if windows[c] == need[c]:
                    valid += 1

            # 判断左窗口是否要收缩
            while valid == len(need):
                # 在这里更新最小覆盖子串
                if right - left < length:
                    start = left
                    length = right - left
                d = s[left]
                left += 1
                if d in need:
                    if windows[d] == need[d]:
                        valid -= 1
                    windows[d] -= 1
                    
        return "" if length == inf else s[start: start + length]
```



### 567 字符串的排列

思路：滑动窗口

```python
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        windows, need = defaultdict(int), defaultdict(int)
        for c in s1:
            need[c] += 1
        left, right = 0, 0
        valid = 0
        while right < len(s2):
            c = s2[right]
            right += 1
            if c in need:
                windows[c] += 1
                if windows[c] == need[c]:
                    valid += 1
            # 判断是否左窗口是否要收缩
            while right - left >= len(s1):
                # 判断是否找到了合法的子串
                if valid == len(need):
                    return True
                d = s2[left]
                left += 1
                if d in need:
                    if windows[d] == need[d]:
                        valid -= 1
                    windows[d] -= 1
        return False
```

> 注意：判断左窗口是否要收缩的条件，是`right - left >= len(s1)`；同样 合法子串的判断条件是`valid == len(need)`。
>
> 注意分辨判断条件。



### 438 找到字符串中所有字母异位词

思路：滑动窗口

```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        windows, need = defaultdict(int), defaultdict(int)
        for c in p:
            need[c] += 1
        left, right = 0, 0
        valid = 0
        ans = []
        while right < len(s):
            c = s[right]
            right += 1
            if c in need:
                windows[c] += 1
                if windows[c] == need[c]:
                    valid += 1
            
            while right - left >= len(p):
                if valid == len(need):
                    ans.append(left)
                d = s[left]
                left += 1
                if d in need:
                    if windows[d] == need[d]:
                        valid -= 1
                    windows[d] -= 1
        return ans
```



## 22.07.14

### 745 前缀和后缀搜索

思路一：哈希暴力

将所有的前缀和后族组合都存入字典，键值为单词索引

```python
class WordFilter:

    def __init__(self, words: List[str]):
        self.map = {}
        for i, word in enumerate(words):
            m = len(word)
            for j in range(1, m + 1):
                for k in range(1, m + 1):
                    self.map[(word[:j], word[-k:])] = i

    def f(self, pref: str, suff: str) -> int:
        return self.map.get((pref, suff), -1)
```

思路二：字典树

这道题是典型字典树应用题。

但是可以不用分别建立前缀树和后缀树，这样虽然判断迅速，但是构建两个树的用时过高了

只需要建立一个前缀树，然后找到以`prefix`作为前缀的单词后，判断后缀是否为`suff`即可。

然后可以用备忘录，记录缓存。

```python
class TrieNode:
    def __init__(self):
        self.string = list()
        self.next = defaultdict(TrieNode)

class Trie:
    def __init__(self):
        self.root = TrieNode()
        
    def add(self, word, index):
        cur = self.root
        for c in word:
            cur = cur.next[c]
            cur.string.append(index)
    
    def search(self, word):
        cur = self.root
        for c in word:
            if c in cur.next:
                cur = cur.next[c]
            else:
                return []
        return cur.string


class WordFilter:

    def __init__(self, words: List[str]):
        self.prefTrie = Trie()
        self.words = words
        for idx, word in enumerate(words):
            self.prefTrie.add(word, idx)
        # 手动记录缓存
        self.memo = {}        

    def f(self, pref: str, suff: str) -> int:
        key = (pref, suff)
        if key in self.memo:
            return self.memo[key]
        for idx in reversed(self.prefTrie.search(pref)):
            if self.words[idx].endswith(suff):
                self.memo[key] = idx 
                return idx
        self.memo[key] = -1
        return -1
```

