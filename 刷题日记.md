# 刷题日记

## **2022.07.07**

### LeetCode23 合并k个有序链表

思路一：堆

python中只有最小堆

可以将所有的节点值都直接放入堆中，然后依次取出链接但是这样的空间复杂度会高O(KN)。

```python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        import heapq
        
        if not lists: return None
        minheap = []
        for item in lists:
            while item:
                heapq.heappush(minheap, item.val)
                item = item.next
        pre = ListNode(-1)
        cur = pre
        while minheap:
            cur.next = ListNode(heapq.heappop(minheap))
            cur = cur.next
        return pre.next
```

空间复杂度优化：创建只有lists.length长度的堆，每次取出最小的节点后，再放入新的节点。

```python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        import heapq
        ListNode.__lt__ = lambda a, b: 0
        if not lists: return None
        nodeheap = []
        for node in lists:
            if node:
                heapq.heappush(nodeheap, (node.val, node))
        dummy = ListNode(-1)
        cur = dummy

        while nodeheap:
            val, node = heapq.heappop(nodeheap)
            cur.next = ListNode(val)
            cur = cur.next
            if node.next:
                heapq.heappush(nodeheap, (node.next.val, node.next))
        return dummy.next
```

思路二：归并法：

```python
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        if not lists: return None
        res = self.mergesort(lists, 0, len(lists) - 1)
        return res
    
    # 边界值的定义要清晰，这里是两边都闭区间
    def mergesort(self, lists, l, r):
        if l == r:
            return lists[l]
        m = (l + r) // 2
        left = self.mergesort(lists, l, m)
        right = self.mergesort(lists, m + 1, r)
        return self.merge(left, right)
    
    def merge(self, l1, l2):
        pre = ListNode(-1)
        cur = pre
        while l1 and l2:
            if l1.val <= l2.val:
                cur.next = l1
                l1 = l1.next
            else:
                cur.next = l2
                l2 = l2.next
            cur = cur.next
        cur.next = l1 if l1 else l2
        return pre.next
```



### LeetCode648 单词替换

思路一：哈希

```python
class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        dictionarySet = set(dictionary)
        words = sentence.split(' ')
        for i, word in enumerate(words):
            for j in range(1, len(words) + 1):
                if word[:j] in dictionarySet:
                    words[i] = word[:j]
                    break
        return ' '.join(words)
```

思路二：字典树

根据题目给的**前缀(词根)创建字典树**，遍历句子中的每个单词，替换为第一个与字典树匹配的前缀。
与其他题目的Trie树的搜索用法不同的是，**我们不需要保证整个单词属于字典树中或整个单词可以拆解成字典树中的单词**，只需要找到第一次匹配到的前缀即可，所以这里写了一个新的查询方法。

```python
class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        trie = Trie()
        for d in dictionary:
            trie.insert(d)
        words = sentence.split(' ')
        return ' '.join(trie.find_sp(word) for word in words) 

class Trie:
    def __init__(self):
        self.root = {}

    def insert(self, word):
        node = self.root
        for w in word + "#":
            if w not in node:
                node[w] = {}
            node = node[w]
    
    def find(self, word):
        node = self.root
        for i in range(len(word)):
            if '#' in node:
                if self.find(word[i:]):
                    return True
            if word[i] in node:
                node = node[word[i]]
            else:
                return False
        return '#' in node

    def find_sp(self, word):
        node = self.root
        for i in range(len(word)):
            if "#" in node:
                return word[:i]
            if word[i] in node:
                node = node[word[i]]
            else:
                break
        return word
```

按照 labuladong 模板的写法：

```python
class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        # 建立前缀树 并把 dictionary 中词根加入到 trie 中
        trie = Trie()
        for d in dictionary:
            trie.insert(d)
        words = sentence.split(' ')
        for i in range(len(words)):
            prefix = trie.shortestPrefix(words[i])
            # 如果找到了最短前缀就用 prefix 替换
            if prefix:
                words[i] = prefix
        return ' '.join(words)

class Node:
    def __init__(self):
        self.children = collections.defaultdict(Node)
        self.isword = False

class Trie:
    def __init__(self):
        self.root = Node()
    
    def insert(self, word):
        node = self.root
        for w in word:
            node = node.children[w]
        node.isword = True
    
    def find(self, word):
        node = self.root
        for w in word:
            node = node.children.get(w)
            if node == None:
                return False
        return node.isword
    
    # 在所有键中找到 word 的最短前缀
    def shortestPrefix(self, word):
        node = self.root
        for i in range(len(word)):
            # 无法继续向下搜索
            if node == None:
                return ""
            # 找到一个键是 word 的前缀
            if node.isword:
                return word[:i]
            # 向下搜索
            node = node.children.get(word[i])
        # 如果 word 本身就是一个键
        if node and node.isword:
            return word
        return ""
```







## **2022.07.08**

### LeetCode208 实现前缀树

这里只需要insert search startswith几个函数即可

```python
class Node:
    def __init__(self):
        self.children = collections.defaultdict(Node)
        self.isword = False

class Trie:

    def __init__(self):
        self.root = Node()

    def insert(self, word: str) -> None:
        node = self.root
        for w in word:
            node = node.children[w]
        node.isword = True

    def search(self, word: str) -> bool:
        node = self.root
        for w in word:
            node = node.children.get(w)
            if node == None:
                return False
        return node.isword

    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for w in prefix:
            node = node.children.get(w)
            if node == None: return False
        return True
```



### LeetCode211 添加查找单词

思路一：字典树

负雪明烛方法一：（超时）
```python
class Node:
    def __init__(self):
        self.children = collections.defaultdict(Node)
        self.isEnd = False

class WordDictionary(object):

    def __init__(self):
        self.root = Node()

    def addWord(self, word):
        node = self.root
        for w in word:
            node = node.children[w]
        node.isEnd = True

    def search(self, word):
        return self.match(word, idx, self.root)
    
    def match(word, idx, root):
        if not root:
            return False
        if idx == len(word):
            return root.isEnd
        if word[idx] != '.':
            return root and self.match(word, idx + 1, root.children.get(word[idx]))
        else:
            for child in root.children.values():
                if self.match(word, idx + 1, child):
                    return True
        return False
```

Ben bfs方法：（不超时）

```python
class WordDictionary(object):

    def __init__(self):
        self.trie = dict()

    def addWord(self, word):
        node = self.trie
        for ch in word:
            if ch not in node:
                node[ch] = {}
            node = node[ch]
        node["#"] = {}

    def search(self, word):
        word += '#'
        bfs = deque([(0, self.trie)])
        while bfs:
            idx, cur = bfs.popleft()
            if idx == len(word):
                return True
            if word[idx] == '.':
                for nxt in cur.values():
                    bfs.append((idx + 1, nxt))
            elif word[idx] in cur:
                bfs.append((idx + 1, cur[word[idx]]))
        return False
```

官方标准字典树模板：（不超时）

```python
class TrieNode:
    def __init__(self):
        self.children = [None] * 26
        self.isEnd = False

    def insert(self, word):
        node = self
        for ch in word:
            ch = ord(ch) - ord('a')
            if not node.children[ch]:
                node.children[ch] = TrieNode()
            node = node.children[ch]
        node.isEnd = True
    

class WordDictionary:

    def __init__(self):
        self.trieRoot = TrieNode()

    def addWord(self, word: str) -> None:
        self.trieRoot.insert(word)

    def search(self, word: str) -> bool:

        def dfs(index, node):
            if index == len(word):
                return node.isEnd
            ch = word[index]

            if ch != '.':
                child = node.children[ord(ch) - ord('a')]
                if child is not None and dfs(index + 1, child):
                    return True
            else:
                for child in node.children:
                    if child is not None and dfs(index + 1, child):
                        return True
            return False

        return dfs(0, self.trieRoot)
```

思路二：哈希字典（单词长度作为键值）（超时）

```python
class WordDictionary:

    def __init__(self):
        self.words = collections.defaultdict(list)

    def addWord(self, word: str) -> None:
        self.words[len(word)] += [word]

    def search(self, word: str) -> bool:
        n = len(word)

        def f(s):
            for i in range(n):
                if word[i] not in {s[i], '.'}:
                    return False
            return True

        for s in self.words[n]:
            if f(s):
                return True
        return False
```



### LeetCode677 键值映射

思路一：字典树

不再是TrieSet，而是要记录value值的TrieMap

```python
class MapSum:

    def __init__(self):
        self.root = {}

    def insert(self, key: str, val: int) -> None:
        node = self.root
        for c in key:
            if c not in node:
                node[c] ={}
            node = node[c]
        node['val'] = val

    def sum(self, prefix: str) -> int:
        node = self.root
        for c in prefix:
            if c not in node:
                return 0
            node = node[c]
        ans = 0
        def dfs(node):
            for c in node:
                if c == 'val':
                    nonlocal ans
                    ans += node[c]
                else:
                    dfs(node[c])
        dfs(node)
        return ans
```
思路二：暴力法

使用内置的 startswith 函数进行判断。

```python
class MapSum:

    def __init__(self):
        self.dict = {}

    def insert(self, key: str, val: int) -> None:
        self.dict[key] = val

    def sum(self, prefix: str) -> int:
        res = 0
        for k, v in self.dict.items():
            if k.startswith(prefix):
                res += v
        return res
```



